import PQueue from 'p-queue';
import {
  BuildResultStatus,
  BuildWorkerMessage,
  RepairType,
} from '../builder/builder-types.js';
import { LlmGenerateFilesResponse, LlmRunner } from '../codegen/llm-runner.js';
import { Environment } from '../configuration/environment.js';
import {
  AttemptDetails,
  LlmContextFile,
  LlmResponseFile,
  RootPromptDefinition,
  Usage,
} from '../shared-interfaces.js';
import { BrowserAgentTaskInput } from '../testing/browser-agent/models.js';
import { DEFAULT_MAX_REPAIR_ATTEMPTS } from '../configuration/constants.js';
import { ProgressLogger } from '../progress/progress-logger.js';
import { runBuild } from './build-worker.js';
import { repairAndBuild } from './build-repair.js';

/**
 * Attempts to build the code that an LLM generated. If the build fails, attempts
 * to fix the breakage and build again.
 *
 * @param llm LLM runner.
 * @param model Name of the LLM to use.
 * @param env Environment that is currently being run.
 * @param rootPromptDef Definition of the root prompt.
 * @param directory Directory on disk to which to write.
 * @param contextFiles Files that should be passed as context to the LLM.
 * @param initialOutputFiles Initial files generated by the LLM.
 * @param usage Usage data from the initial LLM run.
 * @param attemptDetails Array tracking information about the current build attempt.
 * @param skipScreenshots Whether to skip taking screenshots of the app.
 * @param skipAxeTesting Whether or not to skip Axe testing of the app.
 * @param abortSignal Signal to fire when the build should be aborted.
 * @param workerConcurrencyQueue Concurrency queue for controlling parallelism of worker invocations (as they are more expensive than LLM calls).
 */
export async function attemptBuild(
  llm: LlmRunner,
  model: string,
  env: Environment,
  rootPromptDef: RootPromptDefinition,
  directory: string,
  contextFiles: LlmContextFile[],
  initialResponse: LlmGenerateFilesResponse,
  attemptDetails: AttemptDetails[],
  skipScreenshots: boolean,
  skipAxeTesting: boolean,
  enableAutoCsp: boolean,
  abortSignal: AbortSignal,
  workerConcurrencyQueue: PQueue,
  progress: ProgressLogger,
  userJourneyAgentTaskInput?: BrowserAgentTaskInput
) {
  const buildParams: BuildWorkerMessage = {
    directory,
    appName: rootPromptDef.name,
    buildCommand: env.buildCommand,
    serveCommand: env.serveCommand,
    takeScreenshots: !skipScreenshots,
    collectRuntimeErrors: true,
    includeAxeTesting: !skipAxeTesting,
    enableAutoCsp: enableAutoCsp,
    userJourneyAgentTaskInput,
  };

  // Clone the original files, because we're going to mutate them between repair
  // attempts and we don't want the different runs to influence each other.
  const finalOutputFiles = initialResponse.files.map((file) => ({
    ...file,
  }));
  let buildResult = await workerConcurrencyQueue.add(
    () => runBuild(buildParams, rootPromptDef, progress),
    { throwOnTimeout: true }
  );
  let repairAttempts = 0;
  let axeRepairAttempts = 0;
  const maxRepairAttempts = llm.hasBuiltInRepairLoop
    ? 0
    : DEFAULT_MAX_REPAIR_ATTEMPTS;

  attemptDetails.push({
    outputFiles: initialResponse.files,
    usage: {
      ...{ inputTokens: 0, outputTokens: 0, totalTokens: 0 },
      ...initialResponse.usage,
    },
    reasoning: initialResponse.reasoning,
    buildResult,
    attempt: 0,
  });

  while (
    buildResult.status !== BuildResultStatus.SUCCESS &&
    repairAttempts < maxRepairAttempts
  ) {
    repairAttempts++;
    progress.log(
      rootPromptDef,
      'build',
      `Trying to repair app build (attempt #${repairAttempts + 1})`
    );

    buildResult = await repairAndBuild(
      llm,
      model,
      env,
      rootPromptDef,
      directory,
      finalOutputFiles,
      buildResult.message,
      'There are the following build errors:',
      contextFiles,
      abortSignal,
      buildParams,
      workerConcurrencyQueue,
      attemptDetails,
      repairAttempts,
      progress,
      RepairType.Build
    );
  }

  // Attempt to repair axe testing as well.
  while (
    (buildResult.axeViolations?.length ?? 0) > 0 &&
    axeRepairAttempts < maxRepairAttempts
  ) {
    axeRepairAttempts++;
    progress.log(
      rootPromptDef,
      'build',
      `Trying to repair axe accessibility violations (attempt #${axeRepairAttempts + 1})...`
    );

    const axeViolationsError = JSON.stringify(
      buildResult.axeViolations,
      null,
      2
    );

    progress.log(rootPromptDef, 'error', 'Found Axe accessibility violations');

    buildResult = await repairAndBuild(
      llm,
      model,
      env,
      rootPromptDef,
      directory,
      finalOutputFiles,
      axeViolationsError,
      'There are the following accessibility errors from axe accessibility violations:',
      contextFiles,
      abortSignal,
      buildParams,
      workerConcurrencyQueue,
      attemptDetails,
      axeRepairAttempts + repairAttempts,
      progress,
      RepairType.Axe
    );

    if (buildResult.axeViolations?.length === 0) {
      progress.log(
        rootPromptDef,
        'success',
        `Successfully fixed all Axe accessibility violations`
      );
    }
  }

  return {
    buildResult,
    outputFiles: finalOutputFiles,
    repairAttempts,
    axeRepairAttempts,
  };
}
